fun inc(-> Int i):
    -> i + 1

fun foo(-> Int a, Int b) -> Int:
    c <- a + b
    a <- b
    return c

fun swap(-> Int a, -> Int b):
    a1 <- a # tu trzeba wykryć, że `a` się dalej nie pojawia, więc nie ma aliasingu
    b -> a
    b <- a1

fun main():
    a <- 0
    b <- 0
    # inc(a);  # error: result ignored
    #_ <- inc(a);  # error: result ignored
                   # It should work for procs but not funs.
    assert a == 0 and b == 0  # nothing changed
    inc(-> a);  # put result in a
    assert a == 1 and b == 0  # a incremented
    b <- inc(a)  # put result in b
    assert a == 1 and b == 2  # b :== a+1
    ! a, b
    c <- foo(-> a, b)
    foo(-> a, b) -> c # same as above
    ! a, b, c
    swap(->b, ->c)
    ! a, b, c
    swap(->a, ->b)
    ! a, b, c
    ! "factorial"
    ! factorial(0), factorial(1), factorial(2), factorial(3), factorial(4), factorial(5)
    #! "factorial1"
    #! factorial1(0), factorial1(1), factorial1(2), factorial1(3), factorial1(4), factorial1(5)
    ! "pow(2, 2) =", pow(2, 2), "  pow(2, 3) =", pow(2, 3)

fun pow(-> Int n, Int p):
    if p < 1:
        n <- 1
    elif p > 1:
        -> n * pow(n, p-1)

fun factorial(Int n) -> Int:
    if n < 2:
        return 1
    else:
        return n * factorial(n-1)

fun factorial1(Int n) -> Int:
    result <- 1
    for i in 2..n:
        -> result * i
    return result
