entrypoints Module, Exp;

layout toplevel ;
layout ":" ;
comment "#";

position token Name ((letter | '_') (letter | digit | '_')* ('\'')*) ;

Mod. Module ::= [TopDef] ;
separator TopDef ";" ;

VariantTypeDef. TopDef ::= "type" Name GenArgsDef ":" "{" [VariantDef] "}" ;
SimpleTypeDef.  TopDef ::= "type" Name GenArgsDef ":" "{" [Field] "}" ;  -- just one variant
ProcDef.        TopDef ::= "proc" Name GenArgsDef "(" [ArgDef] ")" RetType Block ;
FunDef.         TopDef ::= "fun" Name GenArgsDef "(" [ArgDef] ")" RetType Block ;
separator ArgDef "," ;

NoGenArgs. GenArgsDef ::= ;
GenArgs_.  GenArgsDef ::= "[" [CommaName] "]" ;

CommaName_. CommaName ::= Name ;
separator nonempty CommaName "," ;

EmptyVariant.  VariantDef ::= Name ;
SimpleVariant. VariantDef ::= Name "(" [Type] ")" ;
RecordVariant. VariantDef ::= Name ":" "{" [Field] "}" ;
separator nonempty VariantDef ";" ;

FieldDef. Field ::= Type Name ;
separator nonempty Field ";" ;

ValArgDef.  ArgDef ::= Type Name ;
VarArgDef.  ArgDef ::= "->" Type Name ;

Blk. Block ::= ":" "{" [Stmt] "}" ;
separator Stmt ";" ;

separator nonempty Name "." ;

JustType. RetType ::= "->" Type ;
NoType.   RetType ::= ;

NamedType. Type ::= [Name] ;
ArrayType. Type ::= "[" Type "]" ;
TupleType. Type ::= "(" [Type] ")" ;
InstType.  Type ::= [Name] "[" [Type] "]" ; -- generic type instantiation
separator Type "," ;

StmtLet.          Stmt ::= "let" Exp60 "=" Exp ;
StmtTypedLet.     Stmt ::= "let" Exp71 Name "=" Exp ;
StmtAssign.       Stmt ::= Exp "<-" Exp ;
StmtPass.         Stmt ::= "pass" ;
StmtAssert.       Stmt ::= "assert" Exp ;
StmtStatAssert.   Stmt ::= "static" "assert" Exp ;
StmtPrint.        Stmt ::= "!" Exp ;
StmtExp.          Stmt ::= Exp ;
Stmt_Return.      Stmt ::= "return" ;
Stmt_ReturnValue. Stmt ::= "return" Exp ;
Stmt_If.          Stmt ::= "if" Exp Block ;
Stmt_Elif.        Stmt ::= "elif" Exp Block ;
Stmt_Else.        Stmt ::= "else" Block ;
Stmt_While.       Stmt ::= "while" Exp  Block ;
Stmt_ForIn.       Stmt ::= "for" Name "in" Exp Block ;
Stmt_ForVarIn.    Stmt ::= "for" "->" Name "in" Exp Block ;
Stmt_Case.        Stmt ::= "case" [Exp] ":" "{" [CasePattern] "}";
internal Stmt_IfElse. Stmt ::= "if" Exp Block [ElifClause];
separator CasePattern ";" ;

Pattern. CasePattern ::= [Exp] Block ;

Elif. ElifClause ::= "elif" Exp Block ;
terminator ElifClause "" ;

ExpOr. Exp2 ::= Exp2 "or" Exp4 ;

ExpAnd. Exp4 ::= Exp4 "and" Exp6 ;

ExpCmp. Exp6 ::= Exp6 CmpOp Exp8 ;

EqOp. CmpOp ::= "==" ;
NeOp. CmpOp ::= "/=" ;
LtOp. CmpOp ::= "<" ;
GtOp. CmpOp ::= ">" ;
LeOp. CmpOp ::= "=<" ;
GeOp. CmpOp ::= ">=" ;

ExpAdd.   Exp8 ::= Exp8 "+" Exp42 ;
ExpSub.   Exp8 ::= Exp8 "-" Exp42 ;

ExpMul.    Exp42 ::= Exp42 "*" Exp50 ;
ExpDiv.    Exp42 ::= Exp42 "/" Exp50 ;
ExpDivInt. Exp42 ::= Exp42 "//" Exp50 ;
ExpMod.    Exp42 ::= Exp42 "%" Exp50 ;

ExpRange. Exp50 ::= Exp55 ".." Exp55 ;

ExpCall. Exp55 ::= Exp60 "(" [Exp] ")" ;

ExpInt.   Exp60 ::= Integer ;
ExpStr.   Exp60 ::= String ;
ExpArray. Exp60 ::= "[" [Exp] "]" ;
ExpTuple. Exp60 ::= "(" Exp "," [Exp] ")" ;

ExpNot.   Exp60 ::= "not" Exp60 ;
ExpNeg.   Exp60 ::= "-" Exp60 ;

ExpVR.        Exp70 ::= "->" Exp71 ;
ExpVoT.       Exp71 ::= [Name] ; -- var or type
ExpSubscript. Exp71 ::= Exp71 "[" [Exp] "]" ;  -- index projection or generic instantiation

separator Exp ",";
coercions Exp 100 ;
